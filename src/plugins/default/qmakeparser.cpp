/****************************************************************************
**
** Copyright (C) 2006-2009 fullmetalcoder <fullmetalcoder@hotmail.fr>
**
** This file is part of the Edyuk project <http://edyuk.org>
** 
** This file may be used under the terms of the GNU General Public License
** version 3 as published by the Free Software Foundation and appearing in the
** file GPL.txt included in the packaging of this file.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

#include "qmakeparser.h"

/*!
	\file qmakeparser.cpp
	\brief Implementation of the QMakeParser class.
*/

#include "qmakebackend.h"
#include "qmakesettings.h"

#include "plugin.h"

#include "qproject.h"
#include "qprojectmodel.h"

#include <QDir>
#include <QIcon>
#include <QHash>
#include <QStack>
#include <QLabel>
#include <QCache>
#include <QDialog>
#include <QLibrary>
#include <QFileInfo>
#include <QCheckBox>
#include <QGridLayout>
#include <QTextStream>
#include <QLibraryInfo>
#include <QDialogButtonBox>

/*!
	\class QMakeParser
*/

/*!
	\brief ctor
*/
QMakeParser::QMakeParser()
 : QProjectParser()
{
	
}

QMakeParser::~QMakeParser()
{
	
}

QStringList QMakeParser::projectFilters() const
{
	static QStringList m_filters = QStringList()
		<< "QMake projects ( *.pro *.pri *.prf )"
		;
	
	return m_filters;
}

bool QMakeParser::canOpen(const QString& file) const
{
	static QStringList m_exts = QStringList()
		<< "pro"
		<< "pri"
		;
	
	return m_exts.contains(QFileInfo(file).suffix());
}

///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////

// -- Static Data --

// Functions recognized as "script section" starter
static QStringList definitions = QStringList()
	<< "defineTest"
	<< "defineReplace"
	<< "for";

const QRegExp qmakeHeader = QRegExp(
"######################################################################\n"
"# Automatically generated by qmake \\([^)]+\\)[^\n]+\n"
"######################################################################\n"
);

const QRegExp monkeyHeader = QRegExp(
"warning\\(\\s+\"This file has been (generated|generated) by "
"(Qt 4 Developer Studio Monkey|Monkey Studio) \\([^)]+\\)+\\s+"
"-\\s+http://sourceforge.net/projects/(qt4ds-monkey|monkey-studio)\"\\s+\\)"
);

const QRegExp edyukHeader = QRegExp(
"(message|warning)\\(\"project generated by Edyuk)\"\\)\n"
"(message|warning)\\(\"http://edyuk.sourceforge.net\")"
);

// -- End Of Static Data --

void mergeAlternatives(QMakeParser::Token*& t, QString& disp)
{
	while ( t && t->next && (t->text == QMakeTokens::scopeAlterMark) )
	{
		t = t->next;
		disp += '|' + t->text;
		
		if ( t->next && (t->next->text == QMakeTokens::functionOpenMark)  )
		{
			int paren = 0;
			
			do
			{
				t = t->next;
				disp += t->text;
				
				if ( t->text == QMakeTokens::functionOpenMark )
					++paren;
				else if ( t->text == QMakeTokens::functionCloseMark )
					--paren;
				
			} while ( paren && t->next );
		}
	}
}

using namespace QMakeModel;

extern int fillReadOnlyProject(QProject *p, INode *n, const QString& fn);

QProject* QMakeParser::open(const QString& fn)
{
	return QMakeModel::getProjectNode(QFileInfo(fn).absoluteFilePath());
}

bool QMakeParser::parse(QProject *p, INode *n, const QString& fn)
{
	if ( DefaultPlugin::configKey<bool>("QProjectParser/QMakeParser/subset", false) )
	{
		int ret = fillReadOnlyProject(p, n, fn);
		
		return !ret;
	}
	
	QFile file(fn);
	
	if ( !file.open(QFile::ReadOnly | QFile::Text) )
	{
		qWarning("%s : Unable to read file %s", __FUNCTION__, qPrintable(fn));
		return false;
	}
	
	QTextStream in(&file);
	
	QString content = in.readAll()
			.remove(qmakeHeader)
			.remove(monkeyHeader)
			.remove(edyukHeader);
	
	file.close();
	
	//qDebug("parsing file : %s", qPrintable(fn));
	
	TokenList tokens = lex(content.constData(), content.length());
	
	parse(p, n, tokens);
	
	tokens.cleanup();
	
	//qDebug("Done.");
	
	return true;
}

//#define _TRACE_PARSING_

void QMakeParser::parse(QProject *p, INode *top, TokenList& tokens, int index, int max)
{
	if ( max < 0 )
		max = tokens.count();
	
	int scopeNest = 0;
	QStack<int> nests;
	INode *scope = top;
	
	if ( (index >= max) || !scope )
		return;
	
	foreach ( Token *start, tokens )
	{
		if ( start->text.isEmpty() )
			continue;
		
		#ifdef _TRACE_PARSING_
		qDebug("<tokenchain>");
		
		Token *dbg = start;
		forever
		{
			qDebug("\t%s", qPrintable(dbg->text));
			
			if ( !dbg->next )
				break;
			
			dbg = dbg->next;
		}
		
		qDebug("</tokenchain>");
		#endif
		
		// remove single line scopes...
		while ( scopeNest && scope && scope->parent )
		{
			scope = scope->parent;
			--scopeNest;
		}
		
		int scopeCount = 0;
		Token *t = start->next;
		
		if ( start->text == QMakeTokens::commentMark )
		{
			setNextNodeType(QProjectNode::Other);
			INode *n = new INode(
								INode::Comment,
								t ? t->text : QString::null
							);
			
			INodeBackingStore::instance()->appendChild(scope, n, NodeProvider);
			
			continue;
		} else if ( start->text == QMakeTokens::scopeCloseMark ) {
			//qDebug("popped...");
			int n = nests.pop();
			
			while ( n && scope && scope->parent )
			{
				scope = scope->parent;
				--n;
			}
			
			start = t;
			
			if ( start )
				t = start->next;
		}
		
		if ( !t )
			continue;
		
		QString disp = start->text;
		
		while ( t && !QMakeTokens::variableMarks.contains(t->text) )
		{
			if ( t->text == QMakeTokens::functionOpenMark )
			{
				// merge functions body
				if ( !t->next )
				{
					qWarning("%s : malformed function.", __FUNCTION__);
					break;
				}
				
				int paren = 0;
				
				do
				{
					disp += t->text;
					
					if ( t->text == QMakeTokens::functionOpenMark )
						++paren;
					else if ( t->text == QMakeTokens::functionCloseMark )
						--paren;
					
					t = t->next;
					
				} while ( paren && t );
				
				//qDebug("fct %s => %s", qPrintable(disp), qPrintable(t ? t->text : QString()));
				
				if ( disp.startsWith("include(") )
				{
					bool shared = false;
					QString fn = disp.mid(8);
					
					if ( !paren )
						fn.chop(1);
					
					fn = QMakeModel::Search::substitute(
								fn,
								p,
								Search::Project
							).at(0);
					
					if ( p )
						fn = p->absoluteFilePath(fn);
					else
						qDebug("no project...");
					
					setNextNodeType(QProjectNode::Folder);
					
					INode *n = INodeBackingStore::instance()->
							getFileNode(INode::Include, fn, &shared);
					
					INodeBackingStore::instance()->appendChild(
														scope,
														n,
														NodeProvider,
														shared);
					//scope = n;
					
					if ( !shared )
					{
						parse(p, n, fn);
					}
					
					// TODO : check for conditional use...
					break;
					
				} else if ( !t ) {
					// "simple" function...
					//qDebug("fct...");
					
					setNextNodeType(QProjectNode::Other);
					INode *n = new INode(INode::Function, disp);
					
					INodeBackingStore::instance()->appendChild(
														scope,
														n,
														NodeProvider);
					
					break;
				}
				
				//qDebug("merged : %s", qPrintable(disp));
				continue;
			} else if
					(
						(t->text == QMakeTokens::scopeNestMark)
					||
						(t->text == QMakeTokens::scopeOpenMark)
					)
			{
				if ( disp.count() )
				{
					++scopeCount;
					
					//qDebug("scopped...");
					INode *n = new INode(INode::Scope, disp);
					
					setNextNodeType(QProjectNode::Folder);
					
					INodeBackingStore::instance()
											->appendChild(
													scope,
													n,
													NodeProvider
											);
					
					scope = n;
				}
				
				if (
						!t->next
					||
						(
							t->next->next
						&&
							QMakeTokens::variableMarks.contains(t->next->next->text)
						)
					)
				{
					if ( t->text == QMakeTokens::scopeNestMark )
					{
						// purely single line scope
						scopeNest = scopeCount;
						//qDebug("lined...");
					} else {
						// multi line scope
						nests.push(scopeCount);
						
						//qDebug("pushed...");
					}
				}
				
				disp.clear();
			} else {
				disp += t->text;
			}
			
			t = t->next;
		}
		
		if ( !t )
			continue;
		
		if ( QMakeTokens::variableMarks.contains(t->text) )
		{
			//qDebug("var...");
			bool subdirs = disp == QLatin1String("SUBDIRS");
			
			setNextNodeType(QProjectNode::Folder);
			
			INode *v = new INode(INode::Variable, disp + " " + t->text);
			INodeBackingStore::instance()->appendChild(scope, v, NodeProvider);
			
			QProjectNode::NodeType nt = QProjectNode::Other;
			
			if ( subdirs )
				nt = QProjectNode::Project;
			else if ( QMakeTokens::displayedVariables.contains(disp) )
				nt = QProjectNode::File;
			
			setNextNodeType(nt);
			
			while ( t->next && t->next->text.count() )
			{
				t = t->next;
				bool done = false;
				
				if ( subdirs )
				{
					// TODO : support objects...
					QString fn = p->absoluteFilePath(
									QMakeModel::Search::substitute(
										t->text,
										p,
										Search::Project
									).at(0)
								);
					
					QFileInfo info(fn);
					
					if ( info.isDir() )
					{
						QDir d(fn);
						QStringList availables;
						QString pfn = d.absoluteFilePath(info.baseName() + ".pro");
						
						foreach (
									const QFileInfo& i,
									d.entryInfoList(QDir::Files | QDir::Readable)
								)
						{
							if ( i.suffix() == "pro" )
								availables << i.absoluteFilePath();
						}
						
						if ( availables.isEmpty() )
							fn.clear();
						else if ( availables.count() == 1 )
							fn = availables.at(0);
						else if ( availables.contains(pfn) )
							fn = pfn;
						else {
							qWarning("%s : Ambiguous subdir resolution.", __FUNCTION__);
							fn = availables.at(0);
						}
					}
					
					if ( QFile::exists(fn) )
					{
						//qDebug("subdir : %s", qPrintable(fn));
						
						bool shared = false;
					
						INode *sub = INodeBackingStore::instance()
										->getFileNode(INode::Project, fn, &shared);
						
						QList<QProject*> before = p->subProjects();
						
						INodeBackingStore::instance()->appendChild(	v,
																	sub,
																	ProjectProvider,
																	shared);
						
						QList<QProject*> after = p->subProjects();
						
						foreach ( QProject *sp, before )
							after.removeAll(sp);
						
						if ( !shared )
						{
							if ( after.count() != 1 )
								qWarning("quirk...");
							
							parse(after.at(0), sub, fn);
						}
						
						done = true;
					} else {
						qDebug("unable to locate subdir : %s", qPrintable(fn));
					}
				}
				
				if ( !done )
				{
					INode *n = new INode(INode::Value, t->text);
					
					INodeBackingStore::instance()->appendChild(v, n, NodeProvider);
				}
			}
			
		} else {
			qWarning("%s : unhandled token chain.",
					__FUNCTION__);
			
			forever
			{
				qDebug("\t%s", qPrintable(start->text));
				
				if ( !start->next )
					break;
				
				start = start->next;
			}
		}
	}
	
	//qDeleteAll(tokens);
}

#define pre_token_flush(s, d)			\
	d = new Token(s);					\
	if ( token )						\
		l.insert(l.count() - 2, d);		\
	else								\
		l.append(d);					\
	

#define post_token_flush(s)				\
	if ( token )						\
	{									\
		token = token->advance(s);		\
	} else {							\
		token = new Token(s);			\
		l << token;						\
	}									\
	

#define past_token_flush(s, d)			\
	d = new Token(s);					\
	l << d;								\
	

QMakeParser::TokenList QMakeParser::lex(const QChar* data, int length)
{
	int line = 1;
	TokenList l;
	QString buffer;
	bool inVar = false;
	Token *token = 0, *tmp = 0;
	const QChar *start = data, *end = data + length;
	
	while ( data < end )
	{
		while ( data->isSpace() )
		{
			if ( *data == QLatin1Char('\n') )
			{
				if ( (data > start) && (*(data - 1) != QLatin1Char('\\')) )
				{
					token = 0;
					inVar = false;
				}
				
				++line;
			}
			
			++data;
		}
		
		QChar c = *data;
		
		if ( c == QLatin1Char('\"') )
		{
			do
			{
				buffer += *data;
				
				if ( *data == QLatin1Char('\\') )
					buffer += *++data;
				
				++data;
			} while ( (*data != c) && (data < end) );
			
			if ( data < end )
				buffer += *data;
			
			post_token_flush(buffer)
			buffer.clear();
			
		} else if ( c == QLatin1Char('#') ) {
			++data;
			
			pre_token_flush(QMakeTokens::commentMark, tmp)
			
			while ( (data < end) && (*data != QLatin1Char('\n')) )
			{
				buffer += *data;
				++data;
			}
			
			tmp->advance(buffer);
			buffer.clear();
			continue;
			
		} else if ( c == QLatin1Char(',') ) {
			post_token_flush(QString(c))
		} else if ( c == QLatin1Char('|') ) {
			post_token_flush(QString(c))
		} else if ( c == QLatin1Char(':') ) {
			post_token_flush(QString(c))
		} else if ( c == QLatin1Char('=') ) {
			post_token_flush(QString(c))
			inVar = true;
		} else if (
						(
							(c == QLatin1Char('+'))
						||
							(c == QLatin1Char('-'))
						||
							(c == QLatin1Char('*'))
						||
							(c == QLatin1Char('~'))
						)
					&&
						((data + 1) < end)
					&&
						(*(data + 1) == QLatin1Char('='))
				)
		{
			post_token_flush(QString(c) + QString(*++data))
			inVar = true;
			
		} else if ( c == QLatin1Char('$') ) {
			
			++data;
			buffer += c;
			
			while ( (data < end) && (*data == QLatin1Char('$')) )
			{
				buffer += *data;
				++data;
			}
			
			if ( data >= end )
				break;
			
			int paren = 0;
			
			c = *data;
			
			if (
						(c == QLatin1Char('{'))
					||
						(c == QLatin1Char('('))
					||
						(c == QLatin1Char('['))
				  )
			{
				++paren;
			}
			
			bool inText = false, inFunc = false, varTok = paren;
			
			while ( (paren || !data->isSpace()) && (data < end) )
			{
				if (
						!inVar
					&&
						!inFunc
					&&
						!varTok
					&&
						!(
							data->isLetterOrNumber()
						||
							(*data == QLatin1Char('_'))
						||
							(*data == QLatin1Char('('))
						)
					)
					break;
				
				buffer += *data;
				
				++data;
				
				if ( data >= end )
					break;
				
				c = *data;
				
				if (
						!paren
					&&
						(
							(c == ')')
						||
							(c == ']')
						||
							(c == '}')
						)
					)
					break;
				
				if (
						(c == QLatin1Char('{'))
					||
						(c == QLatin1Char('('))
					||
						(c == QLatin1Char('['))
					)
				{
					if ( !(inText || inFunc || varTok) )
					{
						inFunc = true;
						++paren;
					} else if ( !inText ) ++paren;
				} else if (
								(c == QLatin1Char('}'))
							||
								(c == QLatin1Char(')'))
							||
								(c == QLatin1Char(']'))
							)
				{
					if ( !inText ) --paren;
					
					if ( inFunc && !paren )
					{
						buffer += c;
						++data;
						break;
					}
				} else if ( c == QLatin1Char('\"') ) {
					inText = !inText;
				} else if ( (c == QLatin1Char('\\')) && ((data + 1) < end) ) {
					buffer += c;
					buffer += *++data;
				}
			}
			
			post_token_flush(buffer)
			buffer.clear();
			
			continue;
			
		} else if (
						(c == QLatin1Char('{'))
					||
						(c == QLatin1Char('('))
					||
						(c == QLatin1Char('['))
				  )
		{
			post_token_flush(QString(c))
		} else if (
						(c == QLatin1Char('}'))
					||
						(c == QLatin1Char(')'))
					||
						(c == QLatin1Char(']'))
				  )
		{
			//inVar = false;
			post_token_flush(QString(c))
			
		} else if (
						inVar
					&&
						(c == QLatin1Char('\\'))
					&&
						((data + 1) < end)
					&&
						(*(data+1) == QLatin1Char('\n'))
				  )
		{
			++data;
			++line;
		} else {
			
			while (
						(data < end)
					&&
						!data->isSpace()
					&&
						(*data != QLatin1Char('#'))
					&&
						(
							inVar
						||
							(
								(*data != QLatin1Char('('))
							&&
								(*data != QLatin1Char(')'))
							&&
								(*data != QLatin1Char(','))
							&&
								(*data != QLatin1Char('\"'))
							&&
								(*data != QLatin1Char('$'))
							&&
								(*data != QLatin1Char(':'))
							&&
								(*data != QLatin1Char('{'))
							&&
								(*data != QLatin1Char('='))
							&&
								(
									(
										(*data != QLatin1Char('+'))
									&&
										(*data != QLatin1Char('-'))
									&&
										(*data != QLatin1Char('*'))
									&&
										(*data != QLatin1Char('~'))
									)
								||
									(
										((data + 1) < end)
									&&
										(*(data + 1) != QLatin1Char('='))
									)
								)
							)
						)
					)
			{
				buffer += *data;
				++data;
			}
			
			if (
					inVar
				&&
					(data < end)
				)
			{
				
				if ( *data == QLatin1Char('#') )
				{
					post_token_flush(buffer)
					buffer.clear();
					
					do
					{
						buffer += *data;
						++data;
					} while ( (data < end) && (*data != QLatin1Char('\n')) );
					
					past_token_flush(QMakeTokens::commentMark, tmp)
					tmp->advance(buffer);
					buffer.clear();
					continue;
					
				} else if (
						(*data == QLatin1Char('\n'))
					&&
						buffer.count()
					&&
						(buffer.at(buffer.count() - 1) == QLatin1Char('\\'))
					)
				{
					buffer.chop(1);
				}
			}
			
			post_token_flush(buffer)
			buffer.clear();
			
			continue;
		}
		
		++data;
	}
	
	return l;
}
